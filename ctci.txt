
public String joinWords(String[] words){
	StringBuffer sentence = new StringBuffer();
	for(String w:words){
		sentence.append(w);
	}
	return sentence.toString();
}

//question 1.1

public boolean isUniqueChars(String str){
	if(Str.length() > 256) return false;

	boolean[] charSet = new boolean[256];
	for(int i=0;i<str.length();i++){
		int val = str.charAt(i); //返回指定索引出的char值
		if(charSet[val])
			return false;
		charSet[val] = true;
	}
	return true;
}

//question 1.2
//implement in c/c++
void reverse(char* str){
	char* end = str;
	char tmp;
	if(str){
		while(*end){ //find end of the string
			++end;
		}
		--end;//回退一个字符，因为最后一个字符为null
	}

	//从字符串首尾开始交换两个字符，直至两个指针在中间碰头
	while(str < end){
		tmp = *str;
		*str++ = *end;
		*end-- = tmp;
	}
}

//question 1.3
public String sort(String s){
	//将此字符串转换为一个新的字符数组
	char[] content = s.toCharArray();
	java.util.Arrays.sort(content);
	return new String(content);
}

public boolean permutation(String s, String t){
	if(s.length()!=t.length())
		return false;
	return
		sort(s).equals(sort(t));
}

//question 1.4
public void replaceSpaces(char[] str, int length){
	int spacecount = 0, newLength, i;
	for(i=0;i<length;i++){
		if(str[i]==' '){
			spaceCount++;
		}
	}
	newLength = length + spaceCount*2;
	str[newLength] = '\0';
	for(i=length-1;i>=0;i--){
		if(str[i]==' '){
			str[newLength-1] = '0';
			str[newLength-2] = '2';
			str[newLength-3] = '%';
			newLength -= 3;
		}else{
			str[newLength-1] = str[i];
			newLength -= 1;
		}
	}
}

//question 1.5
//iterate through the string, copying characters to a new string
public String compressBad(String str){
	String mystr = "";
	char last = str.charAt(0);
	int count = 1;
	for(int i = 1; i<str.length(); i++){
		if(str.charAt(i)==last){
			count++;
		}else{
			mystr += last + "" + count;
			last = str.charAt(i);
			count = 1;
		}
	}
	return mystr + last + count;
}

//a bettern alg.
public String compressBetter(String str){
	int size = countCompression(str);
	if(size >= str.length()){
		return str;
	}

	StringBuffer mystr = new StringBuffer();
	char last = str.charAt(0);
	int count = 1;

	for(int i = 1; i<str.length(); i++){
		if(str.charAt(i)==last){ //find the duplicate chars
			count++;
		}else{
			mystr.append(last).append(count);
			last = str.charAt(i);
			count = 1;
		}
	}
	mystr.append(last).append(count);
	return mystr.toString();
}

int countCompression(String str){
	if(str == null || str.isEmpty() ) return 0;
	char last = str.charAt(0);
	int size = 0;
	int count = 1;
	for(int i = 1;i<str.length();i++){
		if(str.charAt(i)==last)
			count ++;
		else{
			last = str.charAt(i);
			size += 1 + String.valueOf(count).length();
			count = 1;
		}
	}
	size += 1 + String.valueOf(count).length();
}

//question 1.7
public void setZeros(int[][] matrix){
	boolean[] row = new boolean[matrix.length];
	boolean[] column = new boolean[matrix[0].length];

	//store the row and column index with value 0
	for(int i = 0;i<matrix.length;i++){
		for(int j=0;j<matrix[0].length;j++){
			if(matrix[i][j]==0){
				row[i] = true;
				column[j]=true;
			}
		}
	}

	//set arr[i][j] to 0
	for(int i=0;i<matrix.length;i++){
		for(int j=0;j<matrix[0].length;j++){
			if(row[i]||column[j]){
				matrix[i][j]=0;
			}
		}
	}
}

//question 1.8
//given two strings, s1 and s2, write code to check if s2 is a rotation of s1
//using one call to isSubString(str1,str2)

public boolean isRotation(String s1, String s2){
	int len = s1.length();
	if(len == s2.length() && len>0){
		String s1s1 = s1+s1;
		return isSubstring(s1s1,s2);
	}
	return false;
}


//creating a linked list
class Node {
	Node next = null;
	int data;

	public Node(int d){
		data = d;
	}

	void appendToTail(int d){
		Node end = new Node(d);
		Node n = this;
		while(n.next!=null) {
			n = n.next;
		}
		n.next = end;
	}

	Node deleteNode(Node head, int d){
		Node n = head;
		if (n.data == d){
			return head.next;//moved head
		}

		while(n.next!=null){
			if(n.next.data==d){
				n.next = n.next.next;
				return head;//head didn't change
			}
			n = n.next;
		}
		return head;
	}
}

//question 2.1
public static void deleteDups(LinkedListNode n){
	HashTable table = new HashTable();
	LinkedListNode previous = null;
	while(n!=null){
		if(table.containsKey(n.data))
			previous.next = n.next;
		else{
			table.put(n.data,true);
			previous = n;
		}
		n = n.next;
	}
}

//using runner, whithout buffer
//two pointer: current which iterates through the linked list,
//and runner which checks all subsequent nodes
public static void deleteDups(LinkedListNode head){
	if(head == null)return;

	LinkedListNode current = head;
	while(current!=null){
		//remove all future nodes that have the same value
		LinkedListNode runner = current;
		while(funner.next != null){
			if(runner.next.data == current.data){
				runner.next = runner.next.next;
			}else{
				runner = runner.next;
			}
		}
	}
}

//question2.2 找出单向链表中的倒数第k个节点
//recursive: space O(n)
//solution 1: don't return the element
public static int kthToLast(LinkedListNode head, int k){
	if(head == null) return 0;
	int i = kthToLast(head.next, k) + 1;
	if(i==k)
		System.out.println(head.data);
	return i;
}

//solution 2: use c++ and to pass values by reference
node* kthToLast(node* head, int k, int& i){
	if(head==NULL){
		return NULL;
	}
	node* nd = kthToLast(head->next, k, i);
	i = i+1;
	if(i==k)
		return head;
	return nd;
}

//solution 3: iterative
//using two pointers, p1 and p2
//putting p1 at the begining and moving p2 k nodes into the list
//p2 will hit the end of the linked list after LENGTH - k steps
//time = O(n)  space = O(1)

LinkedListNode kthToLast(LinkedListNode head, int k){
	if(k<=0) return null;

	LinkedListNode p1 = head;
	LinkedListNode p2 = head;

	//move p2 forward k nodes into the list
	for(int i=0;i<k-1;i++){
		if(p2==null) return null;
		p2 = p2.next;
	}
	if(p2==null) return null;

	//move p1 and p2 together
	//when p2 hits the end, p1 will at the Kth to the last
	while(p2.next!=null){
		p1 = p1.next;
		p2 = p2.next;
	}
	return p1;
}

//question 2.3
//delete a node in the middle of a singly linked list
//given only access to that node

//solution: copy the data from the next node over to the current node, and then to delete the next node
public static boolean deleteNode(LinkedListNode n){
	if(n==null||n.next==null)
		return false;
	LinkedListNode next = n.next;
	n.data = next.data;
	n.next = next.next;
	return true;
}

//attention: this problem cannot be solved if the node to be deleted is the last node in the linked list


//question 2.4
//partition a linkd list around a value x
//all nodes less than x come before all nodes
//greater than or equal to x

public LinkedListNode partition(LinkedListNode node, int x){
	LinkedListNode beforeStart = null;
	LinkedListNode beforeEnd = null;
	LinkedListNode afterStart = null;
	LinkedListNode afterEnd = null;

	//partition list
	while(node != null){
		LinkedListNode next = node.next;
		node.next = null;
		if(node.data < x){
			//insert node into end of before list
			if(beforeStart == null){
				beforeStart = node;
				beforeEnd = beforeStart;
			}else{
				beforeEnd.next = node;
				beforeEnd = node;
			}
		}else{
			//insert node into end of after list
			if(afterStart == null){
				afterStart = node;
				afterEnd = afterStart;
			}else{
				afterEnd.next = node;
				afterEnd = node;
			}

		}
		node = next;
	}

	if(beforeStart == null){
		return afterStart;
	}

	//merge before and after
	beforeEnd.next = afterStart;
	return beforeStart;
}


//question 2.5



//question 2.6
//given a circular linked list, implement an algorithm which return
//the node at the beginning of the loop

//solution
//1.create two pointers, FastPointer and SlowPointer
//2.Move FastPointer at a rate of 2 steps and SlowPointer at a rate of 1 step
//3.When they collide, move SlowPointer to LinkedListHead, keep FastPointer where it is
//4.Move SlowPointer and FastPointer at a rate of one step. Return the new collision point

LinkedListNode FindBeginning(LinkedListNode head){
	LinkedListNode slow = head;
	LinkedListNode fast = head;

	//find meeting point
	while(fast != null && fast.next!=null){
		slow = slow.next;
		fast = fast.next.next;
		if(slow==fast){
			break;
		}
	}

	//error check - no meeting point, and therefore no loop
	if(fast == null || fast.next==null){
		return null;
	}

	//move slow to head, keep fast at meeting point
	slow = head;
	while(slow!=fast){
		slow = slow.next;
		fast = fast.next;
	}

	//both now point to the start of the loop
	return fast;
}

//question 2.7
//implement a function to check if a linked list is a palindrome

boolean isPalindrome(LinkedListNode head){
	LinkedListNode fast = head;
	LinkedListNode slow = head;

	Stack<Integer> stack = new Stack<Integer>();

	/*
	* when fast runner reaches the end of the linked list
	* then we know we're at the middle
	*
	*/

	while(fast != null && fast.next != null){
		stack.push(slow.data);
		slow = slow.next;
		fast = falst.next.next;
	}

	//has odd number of elements, so skip the middle element
	if(fast!=null){
		slow = slow.next;
	}

	while(slow!=null){
		int top = stack.pop().intValue();

		//if values are diff, then it's not a palindrome
		if(top!=slow.data){
			return false;
		}
		slow = slow.next;
	}

	return true;
}


//8.3 stack queues
//implement a stack: LIFO
class Stack{
	Node top;

	Object pop(){
		if(top!=null){
			Object item = top.data;
			top = top.next;
			return item;
		}
		return null;
	}

	Object push(Object item){
		Node t = new Node(item);
		t.next = top;
		top = t;

	}

	Object peek(){

	}
}

//implement a queue: FIFO
class Queue{
	Node first, last;

	void enqueue(Object item){
		if(first==null){
			last = new Node(item);
			first = last;
		}else{
			last.next = new Node(item);
			last = last.next;
		}
	}

	Object dequeue(){
		if(first != null){
			Object item = first.data;
			first = first.next;
			return item;
		}
		return null;
	}
}

//question 3.2 design a stack
//push, pop, min which returns the minimum element
//all should operate in O(1) time

public class StackWithMin extends Stack<NodeWithMin>{
	public void push(int value){
		int newMin = Math.min(value, min());
		super.push(new NodeWithMin(value,newMin));
	}

	public int min(){
		if(this.isEmpty()){
			return Integer.MAX_VALUE; //Error value
		}else{
			return peek().min;
		}
	}
}

class NodeWithMin {
	public int value;
	public int min;..

	public NodeWithMin(int v, int min){
		value = v;
		this.min = min;
	}
}

//a better solution
//using an additional stack which keeps track of the mins
public class StackWithMin2 extends Stack<Integer> {
	stack<Integer> s2;
	public StackWithMin2(){
		s2 = new Stack<Integer>();
	}

	public void push(int value){
		if(value <= min()){
			s2.push(value);
		}
		super.push(value);
	}

	public Integer pop(){
		int value = super.pop();
		if(value == min){
			s2.pop();
		}
		return value;
	}

	public int min(){
		if(s2.isEmpty){
			return Integer.MAX_VALUE;
		}else{
			return s2.peek();
		}
	}
}

//question 3.3
//Implement a data structure SefOfStacks
//should be composed of serveral stacks and should create a new stack once the previous one exceeds capacity

class SetOfStack {
	ArrayList<Stack> stacks = new ArrayList<Stack>();

	public void push(int v){
		Stack last = getLastStack();
		if(last != null && !last.isFull()){
			last.push(v);
		} else {
			//must create new stack
			Stack stack = new Stack(capacity);
			stack.push(v);
			stacks.add(stack);
		}
	}

	public int pop(){
		Stack last = getLastStack();
		int v = last.pop();
		if (last.size == 0) stacks.remove(stacks.size() - 1);
		return v;
	}
}

//skip the left ...


//question 3.4 Towers of Hanoi
//3 touwers and N disks
//recursive alg. using pseudocode:

moveDisks(int n, Tower origin, Tower destination, Tower buffer){
	if (n<=0) return;
	//move top n-1 disks from origin to buffer, using destination as a buffer
	moveDisks(n-1, origin, buffer, destination);

	//move top from origin to destination
	moveTop(orign, destination);

	//move top n-1 disks from buffer to destination, using origin as buffer
	moveDisks(n-1, buffer, destination, origin);
}


//implementation
public static void main(String[] args) {
	int n = 3;
	Tower[] towers = new Tower[n];
	for (int i=0; i<3; i++){
		towers[i] = new Tower(i);
	}

	for(int i=n-1;i >=0; i--){
		towers[0].add(i);
	}

	towers[0].moveDisks(n, towers[2], towers[1]);
}

public class Tower {
	private Stack<Integer> disks;
	private int index;
	public Tower(int i){
		disks = new Stack<Integer>();
		index = i;
	}

	public int index(){
		return index;
	}

	public void add(int d){
		if(!disks.isEmpty() && disks.peek() <= d){
			System.out.println("Error placing disk " + d);
		} else {
			disks.push(d);
		}
	}

	public void moveTopTo(Tower t) {
		int top = disks.pop();
		t.add(top);\
		System.out.println("Move disk " + top + " from " + index() +" to " + t.index());
	}

	public void moveDisks(int n, Tower destination, Tower buffer) {
		if(n>0){
			mvoeDisks(n-1, buffer, destination);
			moveTopTo(destination);
			buffer.moveDisks(n-1, destination, this);
		}
	}
}


//question 3.6
//write a program to sort a stack in ascending order (with biggest items on top)

public static Stack<Integer> sort(Stack<Integer> s){
	Stack<Integer> r = new Stack<Integer>();

	while(!s.isEmpty()){
		int tmp = s.pop();
		while( !r.isEmpty && r.peek()>tmp) {
			s.push(tmp);
		}
		return r;
	}
}

// the algorithm is o(n2) time and o(n) space


//question 3.7
//

public abstract class Animal {
	private int order;
	protected String name;
	public Animal(String n){
		name = n;
	}

	public void setOrder(int ord){
		order = ord;
	}

	public int getOrder(){
		return order;
	}

	public boolean isOlderThan(Animal a){
		return this.order < a.getOrder();
	}
}

public class AnimalQueue{
	LinkedList<Dog> dogs = new LinkedList<Dog>();
	LinkedList<Cat> cats = new LinkedList<Cat>();

	private int order = 0;

	public void enqueue(Animal a){
		a.setOrder(order);
		order++;

		if(a instanceof Dog) dogs.addLast((Dog)a);
		else if(a instanceof Cat) cats.addLast((Cat)a);

	}

	public Animal dequeueAny(){
		/*  look at tops of dog and cat queues, and pop the stack with
		* the oldest value.
		*/
		if(dogs.size()==0){
			return dequeueCats();
		}else if(cats.size()==0){
			return dequeueDogs();
		}

		Dog dog = dogs.peek();
		Cat cat = cats.peek();

		if(dog.isOlderThan(cat)){
			return dequeueDogs();
		}else{
			return dequeueCats();
		}
	}

	public Dog dequeueDogs(){
		return dogs.poll();
	}

	public Cat dequeueCats(){
		return cats.poll();
	}
}

public class Dog extends Animal{
	public Dog(String n){
		super(n);
	}
}

public class Cat extends Animal{
	public Cat(String n){
		super(n);
	}
}

//Trees and Graphs
//dfs pseudocode
void search(Node root){
	if (root == null) return;
	visit(root);
	root.visited = true;
	foreach(Node n in root.adjacent){
		if(n.visisted == false){
			search(n);
		}
	}
}

//bfs pseudocode
void search(Node root){
	Queue queue = new Queue();
	root.visisted = true;
	visit(root);
	queue.enqueue(root); //add to end of queue

	while(!queue.isEmpty()){
		Node r = queue.dequeue(); //remove from front of queue
		foreach(Node n in r.adjacent) {
			if(n.visisted == false){
				visist(n);
				n.visisted = true;
				queue.enqueue(n);
			}
		}
	}
}

//question 4.1
//check if a binary tree is balanced
//we can simply recurse through the entire tree, and for each node
//and for each node, comput the heights of each subtree

public static int getHeight(TreeNode root) {
	if(root == null) return 0;
	return Math.max(getHeight(root.left),getHeight(root.right))+1;
}

public static boolean isBalanced(TreeNode root){
	if(root == null)return true;

	int heightDiff = getHeight(root.left) - getHeight(root.right);
	if(Math.abs(heightDiff) >1)
		return false;
	else
		return isBalanced(root.left) && isBalanced(root.right);
}

//improved algorithm
public static int checkHeight(TreeNode root){
	if (root == null){
		return 0;
	}

	//check if left is balanced
	int leftHeight = checkHeight(root.left);
	if(leftHeight == -1){
		return -1; //not balanced
	}

	//check if right is balanced
	int rightHeight = checkHeight(root.right);
	if(rightHeight == -1)
		return -1;

	//check if current node is balanced
	int heightDiff = leftHeight - rightHeight;
	if(Math.abs(heightDiff) > 1)
		return -1;
	else
		return Math.max(leftHeight,rightHeight) + 1;
}

public static boolean isBalanced(TreeNode root){
	if(checkHeight(root) == -1){
		return false;
	}else
		return true;
}
